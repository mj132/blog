import{_ as e,c as s,o as r,a}from"./app.987cfbbf.js";const n="/blog/assets/structure_01.c3588f12.png",o="/blog/assets/structure_02.1e20ca46.png",c="/blog/assets/structure_03.1ab8edb8.png",R=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"React15 架构","slug":"react15-架构","link":"#react15-架构","children":[{"level":3,"title":"Reconciler（协调器）","slug":"reconciler-协调器","link":"#reconciler-协调器","children":[]},{"level":3,"title":"Renderer（渲染器）","slug":"renderer-渲染器","link":"#renderer-渲染器","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"React16架构","slug":"react16架构","link":"#react16架构","children":[{"level":3,"title":"Scheduler（调度器）","slug":"scheduler-调度器","link":"#scheduler-调度器","children":[]},{"level":3,"title":"Reconciler（协调器）","slug":"reconciler-协调器-1","link":"#reconciler-协调器-1","children":[]},{"level":3,"title":"Renderer（渲染器）","slug":"renderer-渲染器-1","link":"#renderer-渲染器-1","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"react/structure.md"}'),l={name:"react/structure.md"},t=a('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>在上一节中我们了解了<code>React</code>的理念，简单概括就是<strong>快速响应</strong>。</p><p><code>React</code>从 v15 升级到 v16 后重构了整个架构。本节我们聊聊 v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构；重构后的 React16 是如何支持异步更新的。</p><h2 id="react15-架构" tabindex="-1">React15 架构 <a class="header-anchor" href="#react15-架构" aria-hidden="true">#</a></h2><p>React15 架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="reconciler-协调器" tabindex="-1">Reconciler（协调器） <a class="header-anchor" href="#reconciler-协调器" aria-hidden="true">#</a></h3><p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等 API 触发更新。</p><p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p><ul><li>调用函数组件、或 class 组件的<code>render</code>方法，将返回的 JSX 转化为虚拟 DOM</li><li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li><li>通过对比找出本次更新中变化的虚拟 DOM</li><li>通知<strong>Renderer</strong>将变化的虚拟 DOM 渲染到页面上</li></ul><blockquote><p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers" target="_blank" rel="noreferrer">这里</a>看到<code>React</code>官方对<strong>Reconciler</strong>的解释</p></blockquote><h3 id="renderer-渲染器" tabindex="-1">Renderer（渲染器） <a class="header-anchor" href="#renderer-渲染器" aria-hidden="true">#</a></h3><p>由于<code>React</code>支持跨平台，所以不同平台有不同的<strong>Renderer</strong>。我们前端最熟悉的是负责在浏览器环境渲染的<strong>Renderer</strong> —— <a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noreferrer">ReactDOM</a>。</p><p>除此之外，还有：</p><ul><li><a href="https://www.npmjs.com/package/react-native" target="_blank" rel="noreferrer">ReactNative</a>渲染器，渲染 App 原生组件</li><li><a href="https://www.npmjs.com/package/react-test-renderer" target="_blank" rel="noreferrer">ReactTest</a>渲染器，渲染出纯 Js 对象用于测试</li><li><a href="https://www.npmjs.com/package/react-art" target="_blank" rel="noreferrer">ReactArt</a>渲染器，渲染到 Canvas, SVG 或 VML (IE8)</li></ul><p>在每次更新发生时，<strong>Renderer</strong>接到<strong>Reconciler</strong>通知，将变化的组件渲染在当前宿主环境。</p><blockquote><p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers" target="_blank" rel="noreferrer">这里</a>看到<code>React</code>官方对<strong>Renderer</strong>的解释</p></blockquote><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h3><p>在<strong>Reconciler</strong>中，<code>mount</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498" target="_blank" rel="noreferrer">mountComponent</a>，<code>update</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877" target="_blank" rel="noreferrer">updateComponent</a>。这两个方法都会递归更新子组件。</p><h4 id="递归更新的缺点" tabindex="-1">递归更新的缺点 <a class="header-anchor" href="#递归更新的缺点" aria-hidden="true">#</a></h4><p>由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。</p><p>在上一节中，我们已经提出了解决办法——用<strong>可中断的异步更新</strong>代替<strong>同步的更新</strong>。那么 React15 的架构支持异步更新么？让我们看一个例子：</p><blockquote><p>初始化时<code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p><p>列表中 3 个元素的值分别为 1，2，3 乘以<code>state.count</code>的结果</p></blockquote><p>我用红色标注了更新的步骤。</p><p><img src="'+n+'" alt="更新流程"></p><p>我们可以看到，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。</p><p>由于整个过程都是同步的，所以在用户看来所有 DOM 是同时更新的。</p><p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p><div class="danger custom-block"><p class="custom-block-title">注意</p><p>以下是我们模拟中断的情况，实际上<code>React15</code>并不会中断进行中的更新</p></div><p><img src="'+o+`" alt="中断更新流程"></p><p>当第一个<code>li</code>完成更新时中断更新，即步骤 3 完成后中断更新，此时后面的步骤都还未执行。</p><p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的 DOM！（即<code>223</code>）</p><p>基于这个原因，<code>React</code>决定重写整个架构。接下来看看重构后的React16是如何支持异步更新的。</p><h2 id="react16架构" tabindex="-1">React16架构 <a class="header-anchor" href="#react16架构" aria-hidden="true">#</a></h2><p>React16架构可以分为三层：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p><h3 id="scheduler-调度器" tabindex="-1">Scheduler（调度器） <a class="header-anchor" href="#scheduler-调度器" aria-hidden="true">#</a></h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p><p>其实部分浏览器已经实现了这个API，这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">requestIdleCallback</a>。但是由于以下因素，<code>React</code>放弃使用：</p><ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li></ul><p>基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。</p><blockquote><p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md" target="_blank" rel="noreferrer">Scheduler</a>是独立于<code>React</code>的库</p></blockquote><h3 id="reconciler-协调器-1" tabindex="-1">Reconciler（协调器） <a class="header-anchor" href="#reconciler-协调器-1" aria-hidden="true">#</a></h3><p>我们知道，在React15中<strong>Reconciler</strong>是递归处理虚拟DOM的。让我们看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673" target="_blank" rel="noreferrer">React16的Reconciler</a>。</p><p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">/** </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">noinline</span><span style="color:#676E95;"> */</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoopConcurrent</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// Perform work until Scheduler asks us to yield</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p><p>在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Placement </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">/*             */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000010</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Update </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">/*                */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> PlacementAndUpdate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">/*    */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000110</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Deletion </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">/*              */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000001000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>全部的标记见<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" target="_blank" rel="noreferrer">这里</a></p></blockquote><p>整个<strong>Scheduler</strong>与<strong>Reconciler</strong>的工作都在内存中进行。只有当所有组件都完成<strong>Reconciler</strong>的工作，才会统一交给<strong>Renderer</strong>。</p><blockquote><p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler" target="_blank" rel="noreferrer">这里</a>看到<code>React</code>官方对React16新<strong>Reconciler</strong>的解释</p></blockquote><h3 id="renderer-渲染器-1" tabindex="-1">Renderer（渲染器） <a class="header-anchor" href="#renderer-渲染器-1" aria-hidden="true">#</a></h3><p><strong>Renderer</strong>根据<strong>Reconciler</strong>为虚拟DOM打的标记，同步执行对应的DOM操作。</p><p>所以，对于我们在上一节使用过的Demo</p><blockquote><p><code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p><p>列表中3个元素的值分别为1，2，3乘以<code>state.count</code>的结果</p></blockquote><p>在React16架构中整个更新流程为：</p><p><img src="`+c+'" alt="更新流程"></p><p>其中红框中的步骤随时可能由于以下原因被中断：</p><ul><li>有其他更高优任务需要先更新</li><li>当前帧没有剩余时间</li></ul><p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即v15演示的情况）。</p><blockquote><p>实际上，由于<strong>Scheduler</strong>和<strong>Reconciler</strong>都是平台无关的，所以<code>React</code>为他们单独发了一个包<a href="https://www.npmjs.com/package/react-reconciler" target="_blank" rel="noreferrer">react-Reconciler</a>。你可以用这个包自己实现一个<code>ReactDOM</code>。</p></blockquote><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p><p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p><p><code>Fiber</code>是什么？它和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来的文章解答。</p>',67),p=[t];function d(i,h,u,g,b,D){return r(),s("div",null,p)}const F=e(l,[["render",d]]);export{R as __pageData,F as default};
