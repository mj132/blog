import{_ as e,c as r,b as s,e as l,w as p,d as n,a as o,r as c,o as t}from"./app.987cfbbf.js";const N=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么出现Promise","slug":"为什么出现promise","link":"#为什么出现promise","children":[]},{"level":2,"title":"Promise的含义","slug":"promise的含义","link":"#promise的含义","children":[]},{"level":2,"title":"Promise原理与讲解","slug":"promise原理与讲解","link":"#promise原理与讲解","children":[]},{"level":2,"title":"Promise在开发中的应用","slug":"promise在开发中的应用","link":"#promise在开发中的应用","children":[]},{"level":2,"title":"Promise使用过程中注意事项与误区","slug":"promise使用过程中注意事项与误区","link":"#promise使用过程中注意事项与误区","children":[]},{"level":2,"title":"Promise的反思","slug":"promise的反思","link":"#promise的反思","children":[]}],"relativePath":"front-end/javascript/promise.md"}'),F={name:"front-end/javascript/promise.md"},y=o("",18),D=s("li",null,"在异步操作完成之后，会针对不同的返回结果调用resolve和reject。",-1),i=s("li",null,"resolve和reject是两个函数，resolve是异步操作成功时候被调用，将异步操作的返回值作为参数传递到外部；reject是异步操作出异常时候被调用，将错误信息作为参数传递出去。",-1),A=s("li",null,"resolve函数和reject函数只是把异步结果传递出去",-1),C=o("",7),u=o("",3),m=s("li",null,"对于这个空对象我们如果想继续做一些什么，需要进行处理，可以用非空Promise对这个空的进行赋值覆盖，然后继续then的链式调用。",-1),b=o("",11),d=s("li",null,"promise.all对多个执行结果做一个包装传给了then",-1),h=s("li",null,"all中的promise，如果有一个状态变成了reject，那么转换后的Promise直接变成reject，错误信息传递给catch，不会传递给then。（但是并不是说all这里面刚开始执行成功的操作就不算数了）",-1),_=o("",6),v=s("li",null,"状态不可逆性",-1),f=s("li",null,"resolve函数和reject函数只是传递异步结果",-1),g=s("li",null,"then进行层级调用的时候，每次的返回值都是一个空promise对象，如果想继续使用，赋值替换掉空promise对象，但是返回的时候return关键字很重要，不要忘了。",-1),P=s("li",null,"promise.all中的执行顺序是并行的，但是会等全部完成的结果传递给then",-1),E=o("",5);function T(j,k,S,w,V,x){const a=c("font");return t(),r("div",null,[y,s("ul",null,[D,i,s("li",null,[l(a,{color:"red"},{default:p(()=>[n("Promise其实没有做任何实质的代码操作，它只是对异步操作回调函数的不同结果定义了不同状态。")]),_:1})]),A]),C,s("ul",null,[s("li",null,[n("注意then方法"),l(a,{color:"red"},{default:p(()=>[n("只是")]),_:1}),n("用来获取异步操作的值。")])]),u,s("ul",null,[s("li",null,[n("上面的第二个then方法中的值虽然是未定义，但是每一个then一定会"),l(a,{color:"red"},{default:p(()=>[n("返回一个新的promise对象")]),_:1}),n("，但是默认是一个空对象。")]),m,s("li",null,[n("then 中的"),l(a,{color:"red"},{default:p(()=>[n("return")]),_:1}),n("关键字很重要，联系着下一个then的调用。")])]),b,s("ul",null,[d,s("li",null,[n("promise.all中的执行顺序是怎么样的，Promise的执行顺序是从被创建开始的，也就是在调用all的时候，"),l(a,{color:"red"},{default:p(()=>[n("所有的promise都已经开始执行了，all方法只是等到所有的对象都执行完成，才会把结果传递给then")]),_:1}),n("。")]),h]),_,s("ul",null,[v,f,g,P,s("li",null,[l(a,{color:"red"},{default:p(()=>[n("执行顺序")]),_:1}),n("，promise是then方法调用之后才会执行吗？还是从创建那一刻就开始执行？promise从创建那一刻就开始执行，只是把结果传递给了then，then与promise的执行无关。")])]),E])}const B=e(F,[["render",T]]);export{N as __pageData,B as default};
