import{_ as e,c as t,o as a,a as r}from"./app.941c4894.js";const i="/blog/assets/pipeline1.9204a291.png",n="/blog/assets/pipeline2.8daf92fd.png",l="/blog/assets/async-defer.03d8feff.jpeg",S=JSON.parse('{"title":"四、页面解析与处理","description":"","frontmatter":{},"headers":[{"level":2,"title":"主要工作","slug":"主要工作","link":"#主要工作","children":[]},{"level":2,"title":"1. 注意资源在页面文档中的位置","slug":"_1-注意资源在页面文档中的位置","link":"#_1-注意资源在页面文档中的位置","children":[]},{"level":2,"title":"2. 使用 defer 和 async","slug":"_2-使用-defer-和-async","link":"#_2-使用-defer-和-async","children":[]},{"level":2,"title":"3. 页面文档压缩","slug":"_3-页面文档压缩","link":"#_3-页面文档压缩","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"performance/parse.md"}'),c={name:"performance/parse.md"},d=r('<h1 id="四、页面解析与处理" tabindex="-1">四、页面解析与处理 <a class="header-anchor" href="#四、页面解析与处理" aria-hidden="true">#</a></h1><p>在上一站中，我们简单介绍了服务端处理与响应，到目前为止我们已经经历了很多环节，也已经有了许多「性能优化的武器」。像是</p><ul><li>利用各级缓存进行优化</li><li>提前进行 DNS 查询或建立连接等方式加速请求</li><li>在服务端避免不必要的耗时</li><li>……</li></ul><p>不过，不要掉以轻心，后续仍然有大量的工作等待我们来优化。下面就到了客户端接收响应的阶段了。</p><h2 id="主要工作" tabindex="-1">主要工作 <a class="header-anchor" href="#主要工作" aria-hidden="true">#</a></h2><p>这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：</p><ul><li>页面 DOM 的解析；</li><li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li><li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li></ul><p>大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。</p><h2 id="_1-注意资源在页面文档中的位置" tabindex="-1">1. 注意资源在页面文档中的位置 <a class="header-anchor" href="#_1-注意资源在页面文档中的位置" aria-hidden="true">#</a></h2><p>我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。</p><p>JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。</p><p>仅仅看 DOM 与 CSS 的关系，则如下图所示：</p><p><img src="'+i+'" alt="pipeline for dom and css"></p><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p><p><img src="'+n+'" alt="pipeline for dom and css with js"></p><p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 ——</p><blockquote><p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。</p></blockquote><p>所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <code>&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code>&lt;body&gt;</code> 的最后（即页面的尾部）。</p><p>关于这部分的一些解释可以看<a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/" target="_blank" rel="noreferrer">这篇文章</a><sup>[1]</sup>。</p><h2 id="_2-使用-defer-和-async" tabindex="-1">2. 使用 defer 和 async <a class="header-anchor" href="#_2-使用-defer-和-async" aria-hidden="true">#</a></h2><p>上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。</p><p>那除了将脚本放在 <code>body</code> 的最后，还有什么优化方法么？是有的。</p><p>可以使用 <code>defer</code> 或 <code>async</code> 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p><p><img src="'+l+'" alt="async defer"></p><p><code>defer</code> 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 <code>async</code> 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p><table><thead><tr><th style="text-align:center;">script 标签</th><th style="text-align:center;">JS 执行顺序</th><th style="text-align:center;">是否阻塞解析 HTML</th></tr></thead><tbody><tr><td style="text-align:center;"><code>&lt;script&gt;</code></td><td style="text-align:center;">在 HTML 中的顺序</td><td style="text-align:center;">阻塞</td></tr><tr><td style="text-align:center;"><code>&lt;script async&gt;</code></td><td style="text-align:center;">网络请求返回顺序</td><td style="text-align:center;">可能阻塞，也可能不阻塞</td></tr><tr><td style="text-align:center;"><code>&lt;script defer&gt;</code></td><td style="text-align:center;">在 HTML 中的顺序</td><td style="text-align:center;">不阻塞</td></tr></tbody></table><p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 <code>async</code> 可以有效避免这些非核心功能的加载影响页面解析速度。</p><h2 id="_3-页面文档压缩" tabindex="-1">3. 页面文档压缩 <a class="header-anchor" href="#_3-页面文档压缩" aria-hidden="true">#</a></h2><p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p><hr><p>说一句题外话，你知道与页面解析密切相关的 DOMContentLoaded 事件何时触发么？interactive/complete 等 readyState 具体代表什么么？如果不太了解可以从<a href="https://html.spec.whatwg.org/multipage/dom.html#current-document-readiness" target="_blank" rel="noreferrer">HTML spec</a><sup>[2]</sup>里看。</p><p>用原话来说就是：</p><blockquote><p>Returns &quot;loading&quot; while the Document is loading, &quot;interactive&quot; once it is finished parsing but still loading subresources, and &quot;complete&quot; once it has loaded.</p></blockquote><blockquote><p>The readystatechange event fires on the Document object when this value changes.</p></blockquote><blockquote><p>The DOMContentLoaded event fires after the transition to &quot;interactive&quot; but before the transition to &quot;complete&quot;, at the point where all subresources apart from async script elements have loaded.</p></blockquote><hr><p>好了，在这一站我们又了解了页面的解析过程及其性能优化。</p><p>正如开头所说，其实解析页面、加载资源、使用资源是三个紧密相关的过程。在这里我们主要着眼于页面的解析，而在「前端性能优化之旅」的下一站，我们则会一起来涉足到这部分的其他诸多优化点中。</p><hr><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ol><li><a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/" target="_blank" rel="noreferrer">Deciphering the Critical Rendering Path</a></li><li><a href="https://html.spec.whatwg.org/multipage/dom.html#current-document-readiness" target="_blank" rel="noreferrer">HTML5 spec: current-document-readiness</a></li><li><a href="https://medium.com/@raviroshan.talk/async-defer-javascript-loading-strategies-da489a0ba47e" target="_blank" rel="noreferrer">Async Defer — JavaScript Loading Strategies</a></li><li><a href="https://medium.com/@nikjohn/speed-up-google-maps-and-everything-else-with-async-defer-7b9814efb2b" target="_blank" rel="noreferrer">Speed up Google Maps(and everything else) with async &amp; defer</a></li><li><a href="https://html.spec.whatwg.org/multipage/parsing.html#the-end" target="_blank" rel="noreferrer">HTML5 spec: parse HTML (the end)</a></li></ol>',41),s=[d];function p(o,h,g,u,f,_){return a(),t("div",null,s)}const b=e(c,[["render",p]]);export{S as __pageData,b as default};
