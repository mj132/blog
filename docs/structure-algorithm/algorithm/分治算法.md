## 前言

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于 n 个元素的排序问题，当 n=1 时，不需任何计算。n=2 时，只要作一次比较即可排好序。n=3 时只要作 3 次比较即可，…。而当 n 较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

## 基本思想及策略

**分治法的设计思想是**：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

**分治策略**：对于一个规模为 `n` 的问题，若该问题可以容易地解决（比如说规模 `n` 较小）则直接解决，否则将其分解为 `k` 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做**分治法**。

如果原问题可分割成 `k` 个子问题，`1<k≤n` ，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种**分治法**就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。**分治与递归**像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

## 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P。

### 思路

使用暴力法：从第一个数开始，依次和后面每一个数字进行比较记录逆序对的个数，时间复杂度 `O(n²)`

使用分治的细想：

若没了解过归并排序，建议先熟悉[归并排序](./sort.md#归并排序)算法再来看本题。

直接将归并排序进行改进，把数据分成`N`个小数组。

这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。

对于两个升序序列，设置两个下标：两个有序序列的末尾。每次比较两个末尾值，如果前末尾大于后末尾值，则有”后序列当前长度“个逆序对；否则不构成逆序对。然后把较大值拷贝到辅助数组的末尾，即最终要将两个有序序列合并到辅助数组并有序。

这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。

**注意和归并排序的区别**：归并排序是合并数组数从小数开始，而本题是从大数开始。

时间复杂度`O(nlogn)`

空间复杂度`O(n)`

### 代码

```js
function InversePairs(data) {
  return mergeSort(data, 0, data.length - 1, [])
}

function mergeSort(array, left, right, temp) {
  if (left < right) {
    const mid = parseInt((left + right) / 2)
    const l = mergeSort(array, left, mid, temp)
    const r = mergeSort(array, mid + 1, right, temp)
    const m = merge(array, left, right, mid, temp)
    return l + m + r
  } else {
    return 0
  }
}

function merge(array, left, right, mid, temp) {
  let leftIndex = mid
  let rightIndex = right
  let tempIndex = right - left
  let count = 0
  while (leftIndex >= left && rightIndex > mid) {
    if (array[leftIndex] > array[rightIndex]) {
      count += rightIndex - mid
      temp[tempIndex--] = array[leftIndex--]
    } else {
      temp[tempIndex--] = array[rightIndex--]
    }
  }
  while (leftIndex >= left) {
    temp[tempIndex--] = array[leftIndex--]
  }
  while (rightIndex > mid) {
    temp[tempIndex--] = array[rightIndex--]
  }
  tempIndex = 0
  for (let i = left; i <= right; i++) {
    array[i] = temp[tempIndex++]
  }
  return count
}
```

### 考察点

- 数组
- 分治
