## 前言

动态规划往往是最能有效考察算法和设计能力的题目类型，面对这类题目最重要的是抓住问题的阶段，了解每个阶段的状态，从而分析阶段之间的关系转化。

适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。

![](https://i.loli.net/2019/08/18/3roOnqlBDEP5RZN.jpg)

自底向上的求解，可以帮你省略大量的复杂计算，例如上面的斐波拉契数列，使用递归的话时间复杂度会呈指数型增长，而动态规划则让此算法的时间复杂度保持在`O(n)`。

## 路径问题

- [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
- [不同路径](https://leetcode-cn.com/problems/unique-paths/)
- [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
- [形成字符串的最短路径](https://leetcode-cn.com/problems/shortest-way-to-form-string)

### 最小路径和

给定一个包含非负整数的 `m x n`  网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

```js
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

**思路**

- 状态定义：

  - 设 `dp` 为大小 `m×n` 矩阵，其中 `dp[i][j]` 的值代表直到走到 `(i,j)` 的最小路径和。

- 转移方程：

> 题目要求，只能向右或向下走，换句话说，当前单元格 `(i,j)` 只能从左方单元格 `(i,j-1)` 或上方单元格 `(i-1,j)` 走到，因此只需要考虑矩阵左边界和上边界。

走到当前单元格 `(i,j)` 的最小路径和 = “从左方单元格 `(i,j-1)` 与 从上方单元格 `(i-1,j)` 走来的 **两个最小路径和中较小的** ” + 当前单元格值 `grid[i][j]`。具体分为以下 4 种情况：

1. **当左边和上边都不是矩阵边界时**：即当 `i ≠ 0, j ≠ 0` 时，`dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`
2. **当只有左边是矩阵边界时**：只能从上面来，即当 `i ≠ 0, j = 0` 时，`dp[i][j] = dp[i - 1][j] + grid[i][j]`
3. **当只有上边是矩阵边界时**：只能从左面来，即当 `i = 0, j ≠ 0` 时，`dp[i][j] = dp[i][j - 1] + grid[i][j]`
4. **当左边和上边都是矩阵边界时**：即当 `i = 0, j = 0` 时，其实就是起点，`dp[i][j] = grid[i][j]`

- 初始状态：

  - `dp` 初始化即可，不需要修改初始 0 值。

- 返回值：

  - 返回 `dp` 矩阵右下角值，即走到终点的最小路径和。

其实我们完全不需要建立 `dp` 矩阵浪费额外空间，直接遍历 `grid[i][j]` 修改即可。这是因为：`grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]` ；原 `grid` 矩阵元素中被覆盖为 `dp` 元素后（都处于当前遍历点的左上方），不会再被使用到。

**复杂度分析：**

- 时间复杂度 O(mn)：遍历整个 `grid` 矩阵元素。
- 空间复杂度 O(1)：直接修改原矩阵，不使用额外空间。

**代码**

```js
var minPathSum = function(grid) {
  var m = grid.length
  var n = grid[0].length
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      if (i === 0 && j !== 0) {
        grid[i][j] += grid[i][j - 1]
      } else if (j === 0 && i !== 0) {
        grid[i][j] += grid[i - 1][j]
      } else if (i !== 0 && j !== 0) {
        grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1])
      }
    }
  }
  return grid[m - 1][n - 1]
}
```

## 买卖股票类问题

- [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)
- [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)
- [打家劫舍](https://leetcode-cn.com/problems/house-robber)
- [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

### 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

```js
示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

```

```js
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**思路**

考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。记：

`f(k)` = 从前 k 个房屋中能抢劫到的最大数额，`Ai` = 第 i 个房屋的钱数。

首先看`n = 1` 的情况，显然 `f(1) = A1`。

再看 `n = 2`，`f(2) = max(A1, A2)`。

对于 `n = 3`，有两个选项:

抢第三个房子，将数额与第一个房子相加。

不抢第三个房子，保持现有最大数额。

显然，你想选择数额更大的选项。于是，可以总结出公式：

`f(k) = max(f(k – 2) + Ak, f(k – 1))`

**代码**

```js
var rob = function(nums) {
  var len = nums.length
  if (len < 2) {
    return nums[len - 1] ? nums[len - 1] : 0
  }
  var current = [nums[0], Math.max(nums[0], nums[1])]
  for (var k = 2; k < len; k++) {
    current[k] = Math.max(current[k - 2] + nums[k], current[k - 1])
  }
  return current[len - 1]
}
```

## 子序列问题

- [不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences)
- [乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray)
- [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)
- [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)

### 最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列**  是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

#### 解法一：动态规划

**思路**

- **状态定义**：

  - `dp[i]` 的值代表 `nums` 以 `nums[i]` 结尾的最长子序列长度。

- **转移方程**：设 `j∈[0,i)`，考虑每轮计算新 `dp[i]` 时，遍历 `[0,i)` 列表区间，做以下判断：

  1. 当 `nums[i]>nums[j]` 时：`nums[i]` 可以接在 `nums[j]` 之后（此题要求严格递增），此情况下最长上升子序列长度为 `dp[j] + 1`
  2. 当 `nums[i] <= nums[j]` 时： `nums[i]` 无法接在`nums[j]` 之后，此情况上升子序列不成立，跳过。

  - 上述所有 1. 情况 下计算出的 `dp[j] + 1`的最大值，为直到 `i` 的最长上升子序列长度（即 `dp[i]`）。实现方式为遍历 `j` 时，每轮执行 `dp[i] = max(dp[i], dp[j] + 1)`。

  - 转移方程： `dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。`

- **初始状态**：

  - `dp[i]` 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。

- **返回值**：

  - 返回 `dp` 列表最大值，即可得到全局最长递增子序列长度。

**复杂度分析**：

- 时间复杂度 `O(N²)`：遍历计算 `dp` 列表需 `O(N)`，计算每个 `dp[i]` 需 `O(N)`。
- 空间复杂度 `O(N)` ：`dp` 列表占用线性大小额外空间。

**代码**

```js
function lis(nums) {
  let len = nums.length,
    dp = new Array(len).fill(1) // 用于保存长度
  for (let i = 0; i < len; i++) {
    let cur = nums[i]
    for (let j = 0; j < i; j++) {
      let pre = nums[j]
      // 如果是递增 取更大的长度值
      if (cur > pre) dp[i] = Math.max(dp[j] + 1, dp[i])
    }
  }
  return Math.max(...dp)
}
```

#### 解法二：动态规划 + 二分查找

**思路**

- **降低复杂度切入点**：解法一中，遍历计算 `dp` 列表需 `O(N)`，计算每个 `dp[k]` 需 `O(N)`。

  1. 动态规划中，通过线性遍历来计算 `dp` 的复杂度无法降低；
  2. 每轮计算中，需要通过线性遍历 `[0,k)` 区间元素来得到 `dp[k]` 。我们考虑：是否可以通过重新设计状态定义，使整个 `dp` 为一个排序列表；这样在计算每个 `dp[k]` 时，就可以通过二分法遍历 `[0,k)` 区间元素，将此部分复杂度由 `O(N)` 降至 `O(logN)`。
  3. 对原序列进行遍历，将每位元素二分插入 `tails` 中。
     - 如果 `tails` 中元素都比它小，将它插到最后
     - 否则，用它覆盖掉比它大的元素中最小的那个。
     - 总之，思想就是让 `tails` 中存储比较小的元素。这样，`tails` 未必是真实的最长递增子序列，但长度是对的。

- **状态定义**：

  - 我们考虑维护一个列表 `tails`，其中每个元素 `tails[k]` 的值代表 长度为 `k+1` 的子序列尾部元素的值。
  - 如 `[1,4,6]` 序列，长度为 `1,2,3` 的子序列尾部元素值分别为 `tails = [1,4,6]`。

- **转移方程**： 设 `res` 为 `tails` 当前长度，代表直到当前的最长递增子序列长度。设 `j∈[0,res)`，考虑每轮遍历 `nums[k]` 时，通过二分法遍历 `[0,res)` 列表区间，找出 `nums[k]` 的大小分界点，会出现两种情况：

  - 区间中存在 `tails[i] > nums[k]` ：将第一个满足 `tails[i] > nums[k]` 执行 `tails[i] = nums[k]`；因为更小的 `nums[k]` 后更可能接一个比它大的数字。
  - 区间中不存在 `tails[i] > nums[k`]： 意味着 `nums[k]` 可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 `res` ），新子序列长度为 `res + 1`。

- 初始状态：

  - 令 `tails` 列表所有值 =0。

- 返回值：

  - 返回 `res` ，即最长递增子序列长度。

**复杂度分析：**

- 时间复杂度 `O(NlogN)`：遍历 `nums` 列表需 `O(N)`，在每个 `nums[i]` 二分法需 `O(logN)`。
- 空间复杂度 `O(N)`：`tails` 列表占用线性大小额外空间。

**代码**

```js
function lis(nums) {
  let len = nums.length,
    tails = new Array(len).fill(0), // 保存元素
    res = 0
  for (let i = 0; i < len; i++) {
    let cur = nums[i],
      start = 0,
      end = res
    while (start < end) {
      let m = Math.floor((start + end) / 2)
      if (tails[m] < cur) {
        start = m + 1
      } else {
        end = m
      }
    }
    tails[start] = cur
    if (res == end) res++
  }
  return res
}
```
