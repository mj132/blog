## 前言

从解决问题每一步的所有可能选项里系统选择出一个可行的解决方案。

在某一步选择一个选项后，进入下一步，然后面临新的选项。重复选择，直至达到最终状态。

回溯法解决的问题的所有选项可以用树状结构表示。

- 在某一步有 n 个可能的选项，该步骤可看作树中一个节点。
- 节点每个选项看成节点连线，到达它的 n 个子节点。
- 叶节点对应终结状态。
- 叶节点满足约束条件，则为一个可行的解决方案。
- 叶节点不满足约束条件，回溯到上一个节点，并尝试其他叶子节点。
- 节点所有子节点均不满足条件，再回溯到上一个节点。
- 所有状态均不能满足条件，问题无解。

**实际上就是一个决策树的遍历过程：**

- 路径：就是已经做出的选择
- 选择列表：就是你当前可以做的选择
- 结束条件：就是到达决策树底层，无法再做选择的条件

回溯算法的框架（伪代码）

```js
const result = []
function backtrack(路径，选择列表){
	if 满足结束条件：
		result.add(路径)
		return
	for 选择 in 选择列表：
		做选择
		backtrack(路径，选择列表)
		撤销选择
}
```

![](https://i.loli.net/2019/08/19/GZkQ7gx9CHsb2hd.png)

> 回溯算法适合由多个步骤组成的问题，并且每个步骤都有多个选项。

## 二叉树中和为某一值的路径

输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

### 思路

套用回溯算法的思路

设定一个结果数组 `result` 来存储所有符合条件的路径

设定一个栈 `stack` 来存储当前路径中的节点

设定一个和 `sum` 来标识当前路径之和

- 从根结点开始深度优先遍历，每经过一个节点，将节点入栈

- 到达叶子节点，且当前路径之和等于给定目标值，则找到一个可行的解决方案，将其加入结果数组

- 遍历到二叉树的某个节点时有 2 个可能的选项，选择前往左子树或右子树

- 若存在左子树，继续向左子树递归

- 若存在右子树，继续向右子树递归

- 若上述条件均不满足，或已经遍历过，将当前节点出栈，向上回溯

### 代码

```js
function FindPath(root, expectNumber) {
  const result = []
  if (root) {
    FindPathCore(root, expectNumber, [], 0, result)
  }
  return result
}

function FindPathCore(node, expectNumber, stack, sum, result) {
  stack.push(node.val)
  sum += node.val
  if (!node.left && !node.right && sum === expectNumber) {
    result.push(stack.slice(0))
  }
  if (node.left) {
    FindPathCore(node.left, expectNumber, stack, sum, result)
  }
  if (node.right) {
    FindPathCore(node.right, expectNumber, stack, sum, result)
  }
  stack.pop()
}
```

### 考察点

- 二叉树
- 回溯算法

## 字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串`abc`,则打印出由字符`a,b,c`所能排列出来的所有字符串`abc,acb,bac,bca,cab`和`cba`。

### 思路

使用回溯法

记录一个字符（`temp`），用于存储当前需要进入排列的字符

记录一个字符串（`current`），用于记录当前已经排列好的字符

记录一个队列（`queue`），用于存储还未被排列的字符

- 每次排列将`temp`添加到`current`
- 如果`queue`为空，则本次排列完成，将`current`加入到结果数组中，结束递归
- 如果`queue`不为空，说明还有未排列的字符
- 递归排列`queue`中剩余的字符
- 为了不影响后续排列，每次递归完成，将当前递归的字符`temp`加回队列

### 代码

> 记录一个当前排列字符 temp

```js
function Permutation(str) {
  const result = []
  if (str) {
    const queue = str.split('')
    PermutationCore(queue, result)
  }
  result.sort()
  return [...new Set(result)]
}

function PermutationCore(queue, result, temp = '', current = '') {
  current += temp
  if (queue.length === 0) {
    result.push(current)
    return
  }
  for (let i = 0; i < queue.length; i++) {
    temp = queue.shift()
    PermutationCore(queue, result, temp, current)
    queue.push(temp)
  }
}
```

> 记录一个当前索引，不断交换数组中的元素（不太好理解，不推荐）

```js
function Permutation(str) {
  var result = []
  if (!str) {
    return result
  }
  var array = str.split('')
  permutate(array, 0, result)
  result.sort()
  return [...new Set(result)]
}

function permutate(array, index, result) {
  if (array.length - 1 === index) {
    result.push(array.join(''))
  }
  for (let i = index; i < array.length; i++) {
    swap(array, index, i)
    permutate(array, index + 1, result)
    swap(array, i, index)
  }
}
```

### 考察点

- 字符串
- 回溯算法

## 和为 sum 的 n 个数

给定无序、不重复的数组`data`，取出 `n` 个数，使其相加和为`sum`

### 思路

基于上面字符串排列题目的变形，我们从`array`中取出`n`个数的全排列，在取的同时判断是否符合条件。

### 代码

```js
function getAllCombin(array, n, sum, temp = []) {
  if (temp.length === n) {
    if (temp.reduce((t, c) => t + c) === sum) {
      return temp
    }
    return
  }
  for (let i = 0; i < array.length; i++) {
    const current = array.shift()
    temp.push(current)
    const result = getAllCombin(array, n, sum, temp)
    if (result) {
      return result
    }
    temp.pop()
    array.push(current)
  }
}
const arr = [1, 2, 3, 4, 5, 6]

console.log(getAllCombin(arr, 3, 10))
```

## N 皇后问题

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png)

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

```js
输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

### 思路

回溯法：深度优先遍历（列数作为同级，行数作为深层）+ 剪枝

- 递归深度达到最后一层：达到一个符合条件的解，向上回溯，向结果中添加当前的皇后位置列表
- 循环所有同级向深层递归，将每一层皇后的位置进行记录
- 当前位置在已放好皇后的攻击范围内：当前位置不能放置皇后
- 没有命中上面的规则，说明当前位置可放置皇后，向更深层递归
- 将结果进行可视化绘制

### 代码

```js
var solveNQueens = function(n) {
  const cols = new Set()
  const left = new Set()
  const right = new Set()
  const result = []
  solveNQueensCore(0, n, cols, left, right, result, [])
  return draw(result, n)
}

var solveNQueensCore = function(row, n, cols, left, right, result, temp) {
  if (row === n) {
    result.push([...temp])
    temp = []
  }
  for (let i = 0; i < n; i++) {
    if (!cols.has(i) && !right.has(row - i) && !left.has(row + i)) {
      cols.add(i)
      left.add(row + i)
      right.add(row - i)
      temp[row] = i
      solveNQueensCore(row + 1, n, cols, left, right, result, temp)
      cols.delete(i)
      left.delete(row + i)
      right.delete(row - i)
    }
  }
}

function draw(array, n) {
  const result = []
  array.forEach((element) => {
    const panel = []
    element.forEach((index) => {
      const temp = new Array(n).fill('.')
      temp[index] = 'Q'
      panel.push(temp.join(''))
    })
    result.push(panel)
  })
  return result
}
```
