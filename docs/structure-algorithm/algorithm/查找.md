## 前言

查找是计算机中最基本也是最有用的算法之一。 它描述了在有序集合中搜索特定值的过程。

![](https://i.loli.net/2019/08/18/Tq6OW3iBvRljHM4.png)

二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。

- [x 的平方根](https://leetcode-cn.com/problems/sqrtx/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china)
- [猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

## 二维数组查找

### 题目

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 基本思路

二维数组是有序的，比如下面的数据：

```
1 2 3
4 5 6
7 8 9
```

可以直接利用左下角数字开始查找：

大于：比较上移

小于：比较右移

### 代码思路

将二维数组看作平面坐标系

从左下角（0,arr.length-1）开始比较：

目标值大于坐标值---x 坐标+1

目标值小于坐标值---y 坐标-1

注意：

二维数组 arr[i][j]中

j 代表 x 坐标

i 代表 y 坐标

### 代码

```js
function Find(target, array) {
  let i = array.length - 1 // y坐标
  let j = 0 // x坐标
  return compare(target, array, i, j)
}

function compare(target, array, i, j) {
  if (array[i] === undefined || array[i][j] === undefined) {
    return false
  }
  const temp = array[i][j]
  if (target === temp) {
    return true
  } else if (target > temp) {
    return compare(target, array, i, j + 1)
  } else if (target < temp) {
    return compare(target, array, i - 1, j)
  }
}
```

### 拓展：二分查找

二分查找的条件是必须有序。

和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。

```js
function binarySearch(data, arr, start, end) {
  if (start > end) {
    return -1
  }
  var mid = Math.floor((end + start) / 2)
  if (data == arr[mid]) {
    return mid
  } else if (data < arr[mid]) {
    return binarySearch(data, arr, start, mid - 1)
  } else {
    return binarySearch(data, arr, mid + 1, end)
  }
}
```

### 考察点

- 查找
- 数组

## 旋转数组的最小数字

### 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为 1。

> NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。

### 基本思路

肯定不能直接遍历，失去了这道题的意义

旋转数组其实是由两个有序数组拼接而成的，因此我们可以使用二分法，只需要找到拼接点即可。

(1)`array[mid] > array[high]`:

出现这种情况的`array`类似`[3,4,5,6,0,1,2]`，此时最小数字一定在 mid 的右边。`low = mid + 1`

(2)`array[mid] == array[high]`:

出现这种情况的`array`类似 `[1,0,1,1,1]`或者`[1,1,1,0,1]`，此时最小数字不好判断在 mid 左边还是右边,这时只好一个一个试 。`high = high - 1`

(3)`array[mid] < array[high]`:

出现这种情况的`array`类似`[2,2,3,4,5,6,6]`,此时最小数字一定就是`array[mid]`或者在`mid`的左边。因为右边必然都是递增的。`high = mid`

### 代码

```js
function minNumberInRotateArray(arr) {
  let len = arr.length
  if (len == 0) return 0
  let low = 0,
    high = len - 1
  while (low < high) {
    let mid = low + Math.floor((high - low) / 2)
    if (arr[mid] > arr[high]) {
      low = mid + 1
    } else if (arr[mid] == arr[high]) {
      high = high - 1
    } else {
      high = mid
    }
  }

  return arr[low]
}
```

## 在排序数组中查找数字

### 题目

统计一个数字在排序数组中出现的次数。

### 思路

本道题有好几种解法

- 1.直接遍历数组，判断前后的值是否相同，找到元素开始位置和结束位置，时间复杂度`O(n)`
- 2.使用二分查找找到目标值，在向前向后遍历，找到所有的数，比上面略优，时间复杂度也是`O(n)`
- 3.使用二分查找分别找到第一个目标值出现的位置和最后一个位置，时间复杂度`O(logn)`

### 代码

在排序数组中找元素，首先考虑使用二分查找

下面是使用二分查找在数组中寻找某个数

```js
function binarySearch(data, arr, start, end) {
  if (start > end) {
    return -1
  }
  var mid = Math.floor((end + start) / 2)
  if (data == arr[mid]) {
    return mid
  } else if (data < arr[mid]) {
    return binarySearch(data, arr, start, mid - 1)
  } else {
    return binarySearch(data, arr, mid + 1, end)
  }
}
```

找到第一次和最后一次出现的位置我们只需要对上面的代码进行稍加的变形

第一次位置：找到目标值，并且前一位的数字和当前值不相等

最后一次位置：找到目标值，并且后一位的数字和当前值不相等

```js
function GetNumberOfK(data, k) {
  if (data && data.length > 0 && k != null) {
    const firstIndex = getFirstK(data, 0, data.length - 1, k)
    const lastIndex = getLastK(data, 0, data.length - 1, k)
    if (firstIndex != -1 && lastIndex != -1) {
      return lastIndex - firstIndex + 1
    }
  }
  return 0
}

function getFirstK(data, first, last, k) {
  if (first > last) {
    return -1
  }
  const mid = parseInt((first + last) / 2)
  if (data[mid] === k) {
    if (data[mid - 1] != k) {
      return mid
    } else {
      return getFirstK(data, first, mid - 1, k)
    }
  } else if (data[mid] > k) {
    return getFirstK(data, first, mid - 1, k)
  } else if (data[mid] < k) {
    return getFirstK(data, mid + 1, last, k)
  }
}

function getLastK(data, first, last, k) {
  if (first > last) {
    return -1
  }
  const mid = parseInt((first + last) / 2)
  if (data[mid] === k) {
    if (data[mid + 1] != k) {
      return mid
    } else {
      return getLastK(data, mid + 1, last, k)
    }
  } else if (data[mid] > k) {
    return getLastK(data, first, mid - 1, k)
  } else if (data[mid] < k) {
    return getLastK(data, mid + 1, last, k)
  }
}
```

### 考察点

- 数组
- 二分查找
